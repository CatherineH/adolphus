"""\
Robot module.

@author: Aaron Mavrinac
@organization: University of Windsor
@contact: mavrin1@uwindsor.ca
@license: GPL-3
"""

from math import pi
from functools import reduce

from geometry import Point, Rotation, Pose
from posable import SceneObject


class RobotLink(SceneObject):
    """\
    Robot link class.

    A L{RobotLink} is a rigid unit of a robot between two joints. It adds some
    functionality related to its robot parent to the base L{SceneObject} class.
    """
    def __init__(self, name, parent, pose=Pose(), mount_pose=Pose(), mount=None,
                 primitives=list(), triangles=list()):
        """\
        Constructor.

        @param name: The name of the object.
        @type name: C{str}
        @param parent: The robot to which this link belongs.
        @type parent: L{Robot}
        @param pose: The pose of the object (optional).
        @type pose: L{Pose}
        @param mount_pose: The transformation to the mounting end (optional).
        @type mount_pose: L{Pose}
        @param mount: The mount of the object (optional).
        @type mount: L{Posable}
        @param primitives: A list of sprite primitive sets (optional).
        @type primitives: C{list} of C{dict}
        @param triangles: The opaque triangles of this object (optional).
        @type triangles: C{list} of L{OcclusionTriangle}
        """
        super(RobotLink, self).__init__(name, pose=pose, mount_pose=mount_pose,
              mount=mount, primitives=primitives, triangles=triangles)
        self.parent = parent

    def visualize(self):
        """\
        Override the parent setting for the sprites generated by a L{RobotLink}
        to the L{Robot} itself.
        """
        super(RobotLink, self).visualize()
        for display in self.displays:
            self.actuals[display].parent = self.parent


class Robot(SceneObject):
    """\
    Sprite-based serial link robot class.

    A L{Robot} object is a composite L{SceneObject}. Externally, it mimics the
    basic L{SceneObject} interface. Internally, it is composed of a set of links
    mounted serially; the overall pose affects the base (first link), and the
    mount pose is taken from the end effector (last link). The configuration of
    the links is dictated by each link's pose and mount pose, which are
    essentially joints and offsets of forward kinematics. The joint
    configuration string induces a set of such poses based on its definition.
    """
    # TODO: describe link definition dict
    def __init__(self, name, pose=Pose(), mount=None, links=list(),
                 config=None, occlusion=True):
        """\
        Constructor.

        @param name: The name of the object.
        @type name: C{str}
        @param pose: The pose of the object (optional).
        @type pose: L{Pose}
        @param mount_pose: The transformation to the mounting end (optional).
        @type mount_pose: L{Pose}
        @param mount: The mount of the object (optional).
        @type mount: L{Posable}
        @param links: List of link definitions.
        @type links: C{list} of C{dict}
        @param config: The initial configuration of the robot.
        @type config: C{list}
        @param occlusion: Enable occlusion triangles in the links if true.
        @type occlusion: C{bool}
        """
        super(Robot, self).__init__(name, pose=pose)
        self.links = []
        # The first link is mounted on the robot's mount, and its relative
        # pose is always equal to the robot's relative pose.
        nextpose = pose
        for i, link in enumerate(links):
            offset = link['offset']
            # Mount each link after the first on its predecessor.
            try:
                pmount = self.links[i - 1]
            except IndexError:
                pmount = mount
            try:
                assert occlusion
                triangles = link['triangles']
            except (AssertionError, KeyError):
                triangles = []
            try:
                primitives = link['primitives']
            except KeyError:
                primitives = []
            self.links.append(RobotLink('%s-%i' % (name, i), self,
                pose=nextpose, mount_pose=offset, mount=pmount,
                primitives=primitives, triangles=triangles))
            nextpose = self.generate_joint_pose(link['joint'])
        self.joints = [link['joint'] for link in links]
        self._config = [joint['home'] for joint in self.joints]
        if config:
            self.config = config
        else:
            # The mount pose of the robot is that of the last link.
            self._mount_pose = self.generate_joint_pose(self.joints[i],
                self.joints[-1]['home']) + (self.links[-1].mount_pose() - \
                self.pose)
        self._visible = False

    def get_config(self):
        """\
        The configuration of this robot.

        @rtype: C{list} of C{float}
        """
        return self._config

    def set_config(self, value):
        if not len(value) == len(self.links):
            raise ValueError('incorrect configuration length')
        for i, position in enumerate(value):
            try:
                self.links[i + 1].relative_pose = \
                    self.generate_joint_pose(self.joints[i], position)
            except IndexError:
                # The mount pose of the robot is that of the last link.
                self._mount_pose = \
                    self.generate_joint_pose(self.joints[i], position) + \
                    (self.links[-1].mount_pose() - self.pose)
            self._config[i] = position
        self._pose_changed_hook()

    config = property(get_config, set_config)

    def get_visible(self):
        """\
        Visibility of this robot.
        """
        return self._visible

    def set_visible(self, value):
        self._visible = value
        for link in self.links:
            link.visible = value

    visible = property(get_visible, set_visible)

    def highlight(self, color=(0, 1, 0)):
        """\
        Highlight this robot with a bright uniform color.

        @param color: The color of the highlight.
        @type color: C{tuple}
        """
        for link in self.links:
            link.highlight(color)

    def unhighlight(self):
        """\
        Unhighlight this robot (if highlighted).
        """
        for link in self.links:
            link.unhighlight()

    def get_absolute_pose(self):
        """\
        The (absolute) pose of the robot.
        """
        return self.links[0].get_absolute_pose()

    def set_absolute_pose(self, pose):
        """\
        Set the absolute (world frame) pose of the robot.

        @param pose: The absolute pose to set.
        @type pose: L{Pose}
        """
        self.links[0].set_absolute_pose(pose)
        super(Robot, self).set_absolute_pose(pose)
    
    absolute_pose = property(get_absolute_pose, set_absolute_pose)
    pose = absolute_pose

    def get_relative_pose(self):
        """\
        The relative pose of the robot.
        """
        return self.links[0].get_relative_pose()

    def set_relative_pose(self, pose):
        """\
        Set the relative (mounted) pose of the robot.

        @param pose: The relative pose to set.
        @type pose: L{Pose}
        """
        self.links[0].set_relative_pose(pose)
        super(Robot, self).set_relative_pose(pose)

    relative_pose = property(get_relative_pose, set_relative_pose)

    def get_mount(self):
        """\
        The mount of this posable.
        """
        try:
            return self.links[0].get_mount()
        except AttributeError:
            return None

    def set_mount(self, value):
        if value:
            self.links[0].set_mount(value)

    mount = property(get_mount, set_mount)

    @staticmethod
    def generate_joint_pose(joint, position=None):
        """\
        Generate the pose of the link required to effect the forward kinematic
        transformation induced by the position value subject to joint
        properties.

        @param joint: The joint description.
        @type joint: C{dict}
        @param position: The position to set (if None, use home position).
        @type position: C{float}
        @return: The pose induced by the forward kinematic transformation.
        @rtype: L{Pose}
        """
        if position is None:
            position = joint['home']
        else:
            if position < joint['limits'][0] or position > joint['limits'][1]:
                raise ValueError('position out of joint range')
        if joint['type'] == 'revolute':
            position *= pi / 180.0
            return Pose(R=Rotation.from_axis_angle(position,
                Point(*joint['axis'])))
        elif joint['type'] == 'prismatic':
            return Pose(T=(Point(*joint['axis']) * position))
        else:
            raise ValueError('invalid joint type')

    @property
    def triangles(self):
        """\
        Occluding triangles (of all links, combined).
        """
        return reduce(lambda a, b: a | b,
            [link.triangles for link in self.links])

    def visualize(self):
        """\
        Visualize this robot.
        """
        for link in self.links:
            link.visualize()
        self._visible = True

    def update_visualization(self):
        """\
        Update this robot's visualization.
        """
        for link in self.links:
            link.opacity = self.opacity
            link.update_visualization()
        for child in self.children:
            try:
                child.update_visualization()
            except AttributeError:
                pass
        
    def toggle_triangles(self):
        """\
        Toggle display of occluding triangles in the visualization.
        """
        for link in self.links:
            link.toggle_triangles()
        self.opacity = self.links[0].opacity
